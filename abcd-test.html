<!DOCTYPE html>
<html>
 <body>
  <p>
  Пусть исполняемая программа хранится в стороке <br>
   str:string[100]; <br>
   переменные <i>a,b,c,d</i> хранятся в массиве <br>
    arr:array[0..3];    
  </p>
  <p>
  Инициализируем переменные <br>
  str:=' a=2 b=3  '; 
  <br>
   Для обработки символов <i>a,b,c,d</i> в тексте программы (сторке <i>srt[]</i>), используется оператор <i>Ord</i>, который преобразует <br>
   букву в её числовой код из ascii-таблицы <br>
   ascii-коды символов, соответствующих буквам <i>a,b,c,d</i> лежат в диапазоне от 97 до 100 
   <pre style="background: #cfffff;">
  var
  test_char:char;
  begin
    test_char:='a';
    writeln(Ord(test_char));
  end.
   </pre>   
   код программы здесь 
   https://github.com/demsp/pas/blob/master/abcd/Ord.pas  
   <br>
   Для посимвольного перебора строки используется цикл <i>while</i> <br>
   Программа по ссылке выводит на экран символы <i>a,b</i> <br>
   https://github.com/demsp/pas/blob/master/abcd/workpiece-billet.pas 
   <br>
   Пускай ascii-коды символов соответствующих переменных, получаемые в результате 
   посимвольного перебора строки <i>str[]</i> загружаются в аккумулятор <i>var_acc</i> <br>
   var_acc:=Ord(str[i]); <br>
  </p>
  <p>
  ascii-коды символов, соответствующих числам, лежат в диапазоне от 48 до 58 <br>
  Пускай цифра, полученная в результате посимвольного перебора строки, загружается в переменную, ascii-код которой хранится в переменной var_acc <br>
  if Ord(str[i])>=48 then if Ord(str[i])<=58 then arr[var_acc-97]:=Ord(str[i])-48;<br> 
  https://github.com/demsp/pas/blob/master/abcd/load_digit_to_arr.pas 
  </p>
  <p>
  Для обмена даными между переменными необходим оператор, который сбрасывает флаг <br>
  Пусть флаг сбрасывается при обработке символа ;<br> 
  if str[i]=';' then flag:=false <br>
  https://github.com/demsp/pas/blob/master/abcd/digit_letter_acc_arr.pas 
  </p>
  <p>
 аккумулятор <i>acc</i> используется для хранения суммы при разборе арифметического выражения, содержащего оператор +    
  
 Если при разборе строки попалось числовое значение, то оно прибавляется к аккумулятору <br>
 acc:=acc+(Ord(str[i])-48); <br>
 Если встретилось имя переменой, то к <i>acc</i> прибавляется значение, содержащиеся в этой переменной <br>
 acc:=acc+arr[Ord(str[i])-97];<br>
 https://github.com/demsp/pas/blob/master/abcd/plus_expression.pas
 </p>
 <p>
 Пусть цикл обрабатывается внутри квадратных скобок <br>
 Пусть переменная, предваряющая скобки, задаёт количество итераций <br>
 Аккумулятор <i>number_of_iterations</i> хранит число, содержащиеся в аккумуляторе <i>var_acc</i> <br>
 в аккумуляторе <i>index_acc</i> лежит индексная переменная <i>i</i> <br>
 положение открывающей скобки [ сохраняется в индексном аккумуляторе <i>index_acc</i>, 
 а переменная <i>var_acc</i> загружается в <i>number_of_iterations</i> <br> 
 флаг сбрасывается
 <pre style="background: #cfffff;">
 if str[i]='[' then
 begin
   index_acc := i;
   number_of_iterations := var_acc;
   flag := false;
 end;  
 </pre> 
 Если в тексте программы встретилась закрывающая скобка ] и если переменная <i>number_of_iterations</i> <br>
 больше нуля, переменная <i>number_of_iterations</i> декрементируется и происходит переход к открывающей скобке
 <pre style="background: #cfffff;">
 if str[i]=']' then
 begin
   arr[number_of_iteration-97] := arr[number_of_iteration-97]-1; 
   i := index_acc;
 end;  
 </pre>
 Если в программе <i>str[]</i> встретилась обратная кавычка, происходит переход к следующему символу <br>
 и на экран выводится требуемый элемент массива <i>arr[]</i> <br>
 и следовательно точку с запятоий после выводимой переменной ставить не обязательно
 https://github.com/demsp/pas/blob/master/abcd/iterations.pas <br>
 Пусть переменные <i>a</i> и <i>b</i> хранят соседние числа Фибоначчи (инициализируются единицами), в переменной <i>с</i> вычисляется 
 сумма этих чисел, переменная <i>d</i> выступает в качестве счетчика итераций <br> 
 тогда программа, выводящая на экран ряд Фибоначчи выглядит так<br> 
 str:= ' a=1; b=1; d=9; [ c=a+b; a=b; b=c; 'b; ] ';
 </p>
 <p>
 Пускай в массиве из пяти элементов хранятся вещественные числа <br>
 arr: array[0..4] of real; <br>
 Тогда в аккумулятор acc тоже должны загружаться вещественные числа <br>
 acc: real; <br> 
 добавим операторы вычитение умножеие деление -*/ <br>
 пусть переменная <i>bin_operator</i> содержит текущий арифметический оператор <br>
 данный символ загружается в переменную <i>bin_operator</i>, если в программе <i>str[]</i> встретились знаки +-*/ <br> 
 if str[i]='+' then bin_operator:='+'; <br>
 if str[i]='-' then bin_operator:='-'; <br> 
 данное число прибавляется к аккумулятору, если в программе <i>str[]</i> встретилось числовое значение и текущим 
 оператором (т.е. символом, содержащимся в переменной bin_operator)
 является + <br>
 if bin_operator='+' then acc:=acc+(Ord(str[i])-48); <br> 
 число вычитается из аккумулятора, если в программе <i>str[]</i> встретилось числовое значение и текущим оператором является - <br>
 if bin_operator='-' then acc:=acc-(Ord(str[i])-48); <br> 
 То же самое для операторов * и / <br>
 if bin_operator='*' then acc:=acc*(Ord(str[i])-48); <br>
 if bin_operator='/' then acc:=acc/(Ord(str[i])-48); <br>
 Пускай переменная прибавляется к аккумулятору, если обрабатываемый символ является буквой <br> 
 if bin_operator='+' then digit_acc:=digit_acc+arr[Ord(str[i])-97];<br>
 То же самое для операторов -*/ <br>
 if bin_operator='-' then digit_acc:=digit_acc-arr[Ord(str[i])-97];<br>
 if bin_operator='*' then digit_acc:=digit_acc*arr[Ord(str[i])-97];<br>
 if bin_operator='/' then digit_acc:=digit_acc/arr[Ord(str[i])-97];<br>
 Приближения к золотому сеченю как отношение двух соседних чисел Фибоначчи можно найти так 
 </p>
  <p>  
  Пускай арифетическое выражение может содержать лишь четыре арифетических опретора <br>
  
  &lt;Expr&gt; ::= &lt;Number&gt; {&lt;Operation&gt; &lt;Number&gt;} <br>
  &lt;Operation&gt; ::= '+' |  '*' <br>
  Фигурные скобки (скобки Клини) обозначают, что к числу рекурсивно присоединяется пара: оператор и число <br>
  и таким образом к.п.г. реализуется цепочка, состоящая из разделённых операторами чисел. <br>  
  Если все операторы имеют одинаковый приоритет, то вычисление результата можно выполнить 
  непосредственно в процессе разбора арифетического выражения, но в данном случае приоритет оператора * выше приретета + <br>

  </p>
 </body> 
</html>  
