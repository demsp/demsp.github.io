<!DOCTYPE html>
<html>
 <body>
 <script src="https://cdnjs.cloudflare.com/ajax/libs/processing.js/1.6.0/processing.min.js"></script>  
  <p>
  Создадим класс <i>Node</i> и объявим корневой узел <i>root</i> <br>
  Корень дерева (а в данном случае списка) инициализируется числовым значением с помощью конструктора класса <i>Node</i>, 
  принимающим в качестве параметра переменную <i>int value</i> <br>
  Метод <i>display()</i> используется для отображения вершины 	  
   <pre style="background: #cfffff;">
   Node root;
   void setup(){
     background(100);
     size(300, 300);
       root = new Node(5);
       root.display();
   }
   class Node{
   int value;
   int x = 50;
   //constructor
   Node(int value){
     this.value = value;
     }
   
   void display(){
     textSize(40);
     text(value, x, 50);
     }
   }
   </pre>
  Метод <i>add()</i> принимает в качестве параметра новый экземпляр класса, то есть элемент типа <i>Node</i>, созданный конструктором класса, 
  сдвигает его по оси <i>x</i>, затем заменяет корневой элемент новым узловым элементом, полученным в качестве параметра
  <pre style="background: #cfffff;">
  Node root;
   void setup(){
     background(100);
     size(300,300);
       root = new Node(5);
       root.display();
           root.add( new Node(3) );
	   root.display();
	   root.add( new Node(7) );
	   root.display();
		 
   }
   class Node{
   int value;
   int x = 50;
   //constructor
   Node(int value){
     this.value = value;
     }
   void add(Node node){
     node.x = x + 50;
     root = node;
   }  
   void display(){
     textSize(40);
     text(value, x, 50);
     }
   }
  </pre>
Визуализация алгоритма отрисовки списка из трёх элементов
<br>  
<script type="application/processing">
Node root;
   void setup(){
     background(100);
     size(300,300);
       root = new Node(5);
       root.display();
		   root.add( new Node(3) );
		   root.display();
		   root.add( new Node(7) );
		   root.display();
		 
   }
   class Node{
   int value;
   int x = 50;
   //constructor
   Node(int value){
     this.value = value;
     }
   void add(Node node){
     node.x = x + 50;
     root = node;
   }  
   void display(){
     textSize(40);
     text(value, x, 50);
     }
   }
	 </script>
<canvas> </canvas>
<br>
Не обязательно выводить элемент каждый раз после добавления к списку<br> 
Пускай метод <i>display()</i> поочерёдно выводит узлы списка в порядке их добавления к списку</br>
Далее для осуществления перехода от одного элемента к другому используется дополнительная переменная <i>next</i>	
<br>
<pre style="background: #cfffff;">
Node root, root_store;
  void setup(){
  background(100);
  size(300,300);
  root = new Node(5);
  root_store = root;
  root.add(new Node(3));
  root.add(new Node(7));
  root.display(root_store);
  }
  
  class Node{
  int value;
  int x = 50;
  Node next;
  Node(int value){this.value = value;}
  
  void add(Node next){ this.next = next; 
            root = this.next;}
	    
  void display(Node node){
     textSize(40);
     while(node != null){
     text(node.value, x, 50);
     node = node.next;
     this.x = x + 50;
     } 
    } 
    
  } 
</pre>
Можно не передавать экземпляр класса в метод <i>add()</i>, вместо этого передавая переменную типа <i>int</i>, обрабатываему конструктором класса внутри 
вспомогательного метода <i>convert()</i> <br>
Вспомогательная переменная <i>next</i> используется методом <i>convert()</i> для создания нового экземпляра класса 
<br>
<pre style="background: #cfffff;">
Node root;
   void setup(){
     background(100);
     size(300,300);
       root = new Node(5);
       root.display();      
       root.add(3);
       root.display();     
       root.add(7);
       root.display();
     
   }
   class Node{
   int value;
   int x = 50;
   Node next = null;
   //constructor
   Node(int value){
     this.value = value;
     }
   
   Node convert(Node next, int value){
   if(next == null) next = new Node(value);
   return next;
   }
   
    void add(int value){ 
     root = convert(next, value);
     root.x = this.x + 50;
   }  
   void display(){
     textSize(40);
     text(value, x, 50);
     }
   }
</pre>
<br>
Далее переменная <i>root_store</i> используется для хранения корневого элемента <br>	
Переменная <i>next</i> возвращается методом <i>convert()</i> как новый экземпляр класса<br>
Оператор <i>while</i> позволяет выводить элементы друг за другом в порядке добавления к списку 	
<pre style="background: #cfffff;">
Node root, root_store;
  void setup(){
  background(100);
  size(300,300);
  root = new Node(5);
  root_store = root;
  root.add(3);
  root.add(7);
  root.display(root_store); 
  }
  
  class Node{
  int value;
  int x = 50;
  Node next;
  Node(int value){this.value = value;}
  
  void add(int value){
  root = convert(next, value);   
  }
  Node convert(Node node, int value){
       if(node == null) node = new Node(value); 
            this.next = node; 
            return this.next;
            }
 
  void display(Node node){
     textSize(40);
     while(node != null){
     text(node.value, x, 50);
     node = node.next;
     this.x = x + 50;
     } 
    }    
  } 
</pre>

</p>
 
 </body>
</html>
