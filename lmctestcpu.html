<!DOCTYPE html>
 <html>
   <boby>
     <p>
       в данном проектируемом ЦПУ память комманд и память данных объединены в один массив RAM <br>
       к адресному входу памяти команд подключен двоичный счётчик, инкрементируемый тактовым сигналом и таким образом
       осуществляющий последовательный перебор команд <br>
       <pre style = "background: #cfffff;">
         counter <= counter + 1;  // инкремент счётчика
       </pre>
     переходы осуществляются загрузкой в счётчик требуемого адреса <br>
     загрузка осуществляется командой <i>counter_load</i> <br>
     <pre style="background: #cfffff;">
       wire [3:0] branch_adr; // адрес перехода
       assign branch_adr = data_in;
       // здесь для примера применяется КМОП таймер +3.3V
       always @(posedge timer555)
       begin
         if (Counter_load) // переход по адресу branch_adr при поступлени команды Counter_load
            counter <= branch_adr; 
          else
            counter <= counter + 1;// инкремент счётчика 
        end
     </pre>
    устройство ввода <i>data_in</i> подключено ко входу двухвходового мультиплексора <i>MUX2</i> <br>
    <br>
    к другому входу подключен сумматор <i>sum</i>
       <pre style="background: #cfffff;">
        assign sum = Acc + RAM;
       </pre>
    прибавляющий к аккумулятору числа, записанные в память <br>
    <br>
    выход мультиплексора <i>MUX2</i> подключен к аккумулятору
    <pre style="background: #cfffff;">
     MUX2 = MUX_switch ? sum : data_in;
    </pre>
    аккумулятор - это четырёхбитный регистр <br>
      <pre style="background: #cfffff;">
        module register4
        (
        input [3:0] reg_data,
        input reg_button,
        output reg [3:0] q 
        );
        always @(posedge reg_button)
          q <= reg_data;
        endmodule    
      </pre>
      порты которого подключены к основному модулю
       <pre style="background: #cfffff;">
       register4 Acc_reg(
         .reg_data(MUX2),
         .reg_button(Acc_button),
         .q(Acc)
       );
      </pre>
Текст модуля под спойлером
<details>
<pre style="background: #cfffff;">	
module register4
(
  input  [3:0] reg_data,
  input reg_button,
  output reg [3:0] q  
);
always @(posedge reg_button)
     	 q <= reg_data;
endmodule

module R (MUX_switch, Acc_button, Acc, counter, timer555, Counter_load, RAM_button, data_in, RAM_out);
   parameter ADDR_WIDTH = 2;
   parameter DATA_WIDTH = 4;
   
   input MUX_switch;
   input Acc_button; 
   output [3:0] Acc;
   
   input timer555, Counter_load;
   output [1:0] counter;
   // input [N-1:0] adr; 
   input RAM_button;
   input [DATA_WIDTH-1:0] data_in;
   output [DATA_WIDTH-1:0] RAM_out;
// Counter
reg [1:0] counter;
always @ (posedge timer555 or posedge Counter_load)
  if (Counter_load)
       counter <= data_in[1:0];  
  else
     counter <= counter + 2'b01;
// RAM 
 wire [ADDR_WIDTH-1:0] adr;
    assign adr = counter;
reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; 
    always @(posedge RAM_button) 
        mem [adr] <= Acc;
assign RAM_out = mem[adr];
// sum 
wire [3:0] sum;
assign sum =  Acc + RAM_out;
// MUX2
reg [3:0] MUX2; 
always @*
MUX2 = MUX_switch ? sum : data_in;
//Acc
register4 Acc_reg(
	.reg_data(MUX2),
	.reg_button(Acc_button),
	.q(Acc)
);
endmodule
	</pre>	
      </details>        
      <br>   
      в следующем модуле добавляется "вычитатель" <br>
      <pre style="background: #cfffff;">
       wire [3:0] subtract;
       assign subtract = Acc - RAM;
      </pre>
     двухвходовой мультиплексор заменяется четырёхвходовым <br>
        <pre style="background: #cfffff;">     
         always @*
         MUX4 = MUX_switch[1] ? (MUX_switch[0] ? RAM_out : subtract)
           :(MUX_switch[0] ? sum : data_in );
        </pre>
        к аккумулятору подключаются флаги <br>
          &bull; Z_flag поднят, если Acc = 0 <br>   
          &bull; PZ_flag поднят, если Acc >= 0 <br>  
        добавляются команды условных переходов <i>Z_JMP</i> и <i>PZ_JMP</i> <br>
        <br>
        <i>wire</i> "соединяет" флаг и команду (входной сигнал) в единый проводник  <br>
        <pre style="background: #cfffff;">
        wire Z, PZ;
        assign Z = Z_JMP & Z_flag;
        assign PZ = PZ_JMP & PZ_flag; 
        </pre>                      
       Текст модуля под спойлером <br>
<details>
<pre style="background: #cfffff;">	
module register4
(
  input  [3:0] reg_data,
  input reg_button,
  output reg [3:0] q  
);
always @(posedge reg_button)
     	 q <= reg_data;
endmodule

module R (JMP, Z_JMP, PZ_JMP, Z_flag, PZ_flag, Output_button, data_out, MUX_switch, Acc_button, 
           Acc, counter, timer555, RAM_button, data_in, RAM_out);
   parameter ADDR_WIDTH = 2;
   parameter DATA_WIDTH = 4;
   
   input JMP, Z_JMP, PZ_JMP;
   output Z_flag, PZ_flag;
   
   // Output
   input Output_button;
   output [3:0] data_out;
   
   input [1:0] MUX_switch;
   input Acc_button; 
   output [3:0] Acc;
   
   input timer555; 
   output [1:0] counter;
   // input [N-1:0] adr; 
   input RAM_button;
   input [DATA_WIDTH-1:0] data_in;
   output [DATA_WIDTH-1:0] RAM_out;
// flags
wire Z,PZ;
assign Z = Z_flag & Z_JMP;
assign PZ = PZ_flag & PZ_JMP;   
// Counter
reg [1:0] counter;
always @ (posedge timer555 or posedge JMP or posedge Z or posedge PZ)
  if (JMP|Z|PZ)
       counter <= data_in[1:0];  
  else
     counter <= counter + 2'b01;
// RAM 
 wire [ADDR_WIDTH-1:0] adr;
    assign adr = counter;
reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; 
    always @(posedge RAM_button) 
        mem [adr] <= Acc;
assign RAM_out = mem[adr];
// sum 
wire [3:0] sum;
assign sum =  Acc + RAM_out;
//subtract
wire [3:0] subtract;
assign subtract =  Acc - RAM_out;
// MUX4
reg [3:0] MUX4; 
always @*
MUX4 = MUX_switch[1] ? (MUX_switch[0] ? RAM_out : subtract)
: (MUX_switch[0] ? sum : data_in);
//Acc
register4 Acc_reg(
	.reg_data(MUX4),
	.reg_button(Acc_button),
	.q(Acc)
);
//data_out
register4 Output_reg(
.reg_data(Acc),
.reg_button(Output_button),
.q(data_out)
);
   assign Z_flag =  ~(|Acc);
   assign PZ_flag =  ~Acc[3];
endmodule 
	</pre>	
         </details>
         <br> 
<hr>		
Основным является модуль, <i>реализующий</i> механизм безусловного перехода <br>
Перебор байтов в ОЗУ осуществляется счётчиком с асинхронным сбросом <i>reset_count</i><br>
<pre style="background: #cfffff;">
  always @ (posedge timer555 or posedge reset_count)	
    if(reset_count)
	counter <= 4'b0000;
    else if(Counter_load) 
	counter <= RAM_out[3:0];
    else 
	counter <= counter + 4'b0001;	
</pre>		
Первые четыре разряда хранящегося в ОЗУ байта являются адресом перехода, в следуючих четырёх разрядах
(а точнее в седьмом бите) хранится команда безусловного перехода <br>
<br>
провод <i>Counter_load</i> связывает седьмой бит с разрешающим портом (портом загрузки) счётчика <br>		
<pre style="background: #cfffff;">
	wire Counter_load; 
	assign Counter_load = RAM_out[7]; 
</pre>
под спойлером  модуль и тестбенч <br>		
<details>
	<pre style="background: #cfffff;">
	module resCount (reset_count, counter, timer555, 
                         RAM_button, data_in, RAM_out);
   parameter ADDR_WIDTH = 4;
   parameter DATA_WIDTH = 8;
      
  input reset_count;
  output [ADDR_WIDTH-1:0] counter;
  input timer555;
  input RAM_button;
  input [DATA_WIDTH-1:0] data_in;
  output [DATA_WIDTH-1:0] RAM_out;
wire Counter_load;
assign Counter_load = RAM_out[7];
reg [ADDR_WIDTH-1:0] counter;
always @ (posedge timer555 or posedge reset_count)
  if (reset_count)
		counter <= 4'b0000;  
  else if (Counter_load) 
		counter <= RAM_out[3:0];  
  else
		counter <= counter + 4'b0001;
 wire [ADDR_WIDTH-1:0] adr;
    assign adr = counter;
reg [DATA_WIDTH-1:0] mem [2**ADDR_WIDTH-1:0]; 
    always @(posedge RAM_button) 
        mem [adr] <= data_in;
assign RAM_out = mem[adr]; 
endmodule

test bench

module tresCount;
   parameter ADDR_WIDTH = 4;
   parameter DATA_WIDTH = 8;

   reg reset_count; 
   reg timer555, RAM_button;
   wire [ADDR_WIDTH-1:0] counter;
   reg [DATA_WIDTH-1:0] data_in;
   wire [DATA_WIDTH-1:0] RAM_out;
resCount test_resCount(reset_count, counter, 
                                 timer555, RAM_button, data_in, RAM_out);
initial // Clock generator
  begin
    timer555 = 0;
    forever #20 timer555 = ~timer555;
  end
initial	
  begin
   	data_in[0] = 0;
	data_in[1] = 0;
	data_in[2] = 0;
	data_in[3] = 0;
	data_in[4] = 0;
	data_in[5] = 0;
	data_in[6] = 0;
	data_in[7] = 0;
	RAM_button = 0;
	reset_count =1;
	#5 reset_count =0;
	#1500 data_in[7] =1;
	#5 RAM_button = 1;
	#5 data_in[7] =0; RAM_button = 0;
  end
endmodule    
</pre>
</details>
		
     </p>  
   </boby>  
 </html>  
